{
  "name": "RAG",
  "nodes": [
    {
      "parameters": {
        "preBuiltAgentsCalloutHttpRequest": "",
        "httpVariantWarning": "",
        "curlImport": "",
        "method": "GET",
        "": "",
        "url": "=https://www.virustotal.com/{{ $json.vtPath }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "virusTotalApi",
        "provideSslCertificates": false,
        "sendQuery": false,
        "sendHeaders": false,
        "sendBody": false,
        "options": {},
        "infoMessage": ""
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        384,
        0
      ],
      "id": "931ec1c4-d209-43ee-aa5c-b4e2907292fa",
      "name": "VirusTotal HTTP Request",
      "extendsCredential": "virusTotalApi"
    },
    {
      "parameters": {
        "preBuiltAgentsCalloutHttpRequest": "",
        "httpVariantWarning": "",
        "curlImport": "",
        "method": "GET",
        "": "",
        "url": "=https://otx.alienvault.com/{{ $json.otxPath }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "alienVaultApi",
        "provideSslCertificates": false,
        "sendQuery": false,
        "sendHeaders": false,
        "sendBody": false,
        "options": {},
        "infoMessage": ""
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        400,
        272
      ],
      "id": "a9d1d275-935a-45bf-ace7-779a5c6574b6",
      "name": "AlienVault HTTP Request",
      "extendsCredential": "alienVaultApi"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node (JS) - Post-Merge reducer (NO heuristics)\n * Input: 2 items appended by Merge: VirusTotal + AlienVault OTX\n * Output: 1 item with:\n *  - summary (structured, compact)\n *  - ai_brief (dense text to send to AI Agent)\n */\n\nconst items = $input.all().map(i => i.json);\n\n// ---------- Helpers ----------\nconst pick = (obj, path, defVal = undefined) => {\n  try {\n    return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj) ?? defVal;\n  } catch { return defVal; }\n};\n\nconst toISO = (epoch) => {\n  if (!epoch) return null;\n  const n = Number(epoch);\n  if (!Number.isFinite(n)) return null;\n  const ms = n > 2e10 ? n : n * 1000; // handles seconds/ms\n  return new Date(ms).toISOString();\n};\n\nconst uniq = (arr) => [...new Set((arr || []).filter(Boolean))];\nconst clampArr = (arr, n) => (arr || []).slice(0, n);\nconst safeStr = (s, max = 400) => {\n  if (!s) return \"\";\n  const t = String(s);\n  return t.length > max ? t.slice(0, max) + \"…\" : t;\n};\n\n// ---------- Identify sources ----------\nconst vt = items.find(x => pick(x, \"data.attributes.last_analysis_stats\") || pick(x, \"data.type\"));\nconst otx = items.find(x => pick(x, \"pulse_info.pulses\") || pick(x, \"pulse_info.count\") || pick(x, \"indicator\"));\n\n// ---------- Parse VirusTotal ----------\nconst vtData = pick(vt, \"data\", {});\nconst vtAttr = pick(vtData, \"attributes\", {});\nconst vtStats = pick(vtAttr, \"last_analysis_stats\", {});\nconst vtResults = pick(vtAttr, \"last_analysis_results\", {});\nconst vtVotes = pick(vtAttr, \"total_votes\", {});\nconst vtCrowd = pick(vtAttr, \"crowdsourced_context\", []);\nconst vtThreatSeverity = pick(vtAttr, \"threat_severity\", {});\nconst vtTags = pick(vtAttr, \"tags\", []);\nconst vtCategories = pick(vtAttr, \"categories\", {});\nconst vtJarm = pick(vtAttr, \"jarm\", null);\n\nconst detections = {\n  malicious: Number(vtStats.malicious ?? 0),\n  suspicious: Number(vtStats.suspicious ?? 0),\n  harmless: Number(vtStats.harmless ?? 0),\n  undetected: Number(vtStats.undetected ?? 0),\n  timeout: Number(vtStats.timeout ?? 0),\n};\n\nconst enginesFlagging = Object.entries(vtResults)\n  .map(([engine, v]) => ({\n    engine,\n    category: v?.category,\n    result: v?.result,\n    method: v?.method,\n  }))\n  .filter(x => x.category === \"malicious\" || x.category === \"suspicious\");\n\nconst vtSummary = {\n  id: vtData?.id,\n  type: vtData?.type,\n  link: pick(vtData, \"links.self\"),\n  reputation: vtAttr?.reputation,\n  votes: { harmless: vtVotes?.harmless ?? 0, malicious: vtVotes?.malicious ?? 0 },\n\n  // Infra / ownership (when IP/domain)\n  country: vtAttr?.country,\n  continent: vtAttr?.continent,\n  asn: vtAttr?.asn,\n  as_owner: vtAttr?.as_owner,\n  network: vtAttr?.network,\n  rir: vtAttr?.regional_internet_registry,\n\n  // Time\n  first_seen_itw: toISO(vtAttr?.first_seen_itw_date),\n  last_seen_itw: toISO(vtAttr?.last_seen_itw_date),\n  last_analysis: toISO(vtAttr?.last_analysis_date),\n  whois_date: toISO(vtAttr?.whois_date),\n\n  // Detections\n  last_analysis_stats: detections,\n  engines_flagging_top: clampArr(enginesFlagging, 12),\n\n  // Useful extras (when present)\n  tags_top: clampArr(vtTags, 20),\n  categories: vtCategories,\n  jarm: vtJarm,\n\n  threat_severity: {\n    level: vtThreatSeverity?.threat_severity_level,\n    description: vtThreatSeverity?.level_description,\n    num_detections: pick(vtThreatSeverity, \"threat_severity_data.num_detections\"),\n    belongs_to_bad_collection: pick(vtThreatSeverity, \"threat_severity_data.belongs_to_bad_collection\"),\n  },\n\n  crowdsourced_context_top: clampArr(vtCrowd, 3).map(c => ({\n    title: c?.title,\n    severity: c?.severity,\n    source: c?.source,\n    timestamp: toISO(c?.timestamp),\n    details: safeStr(c?.details, 350),\n  })),\n};\n\n// ---------- Parse OTX ----------\nconst otxPulses = pick(otx, \"pulse_info.pulses\", []) || [];\nconst otxPulseCount = Number(pick(otx, \"pulse_info.count\", 0));\n\nconst pulsesTop = clampArr(otxPulses, 6).map(p => ({\n  id: p?.id,\n  name: p?.name,\n  description: safeStr(p?.description, 320),\n  created: p?.created,\n  modified: p?.modified,\n  tlp: p?.TLP,\n  tags: clampArr(p?.tags || [], 15),\n  adversary: p?.adversary || \"\",\n  malware_families: (p?.malware_families || []).map(m => m?.display_name || m?.id).filter(Boolean).slice(0, 12),\n  attack_ids: (p?.attack_ids || []).map(a => a?.display_name || a?.id).filter(Boolean).slice(0, 15),\n  targeted_countries: clampArr(p?.targeted_countries || [], 12),\n  references: clampArr(p?.references || [], 8),\n  related_indicator_is_active: p?.related_indicator_is_active ?? 0,\n  author: p?.author?.username,\n}));\n\nconst otxRelated = pick(otx, \"pulse_info.related\", pick(otx, \"related\", {})) || {};\nconst otxReferencesGlobal = uniq([\n  ...(pick(otx, \"pulse_info.references\", []) || []),\n  ...(pick(otx, \"references\", []) || []),\n]).slice(0, 25);\n\nconst otxSummary = {\n  indicator: pick(otx, \"indicator\"),\n  type: pick(otx, \"type\"),\n  reputation: pick(otx, \"reputation\"),\n  whois: pick(otx, \"whois\"),\n  pulse_count: otxPulseCount,\n  pulses_top: pulsesTop,\n  related: {\n    malware_families: uniq([\n      ...(pick(otxRelated, \"alienvault.malware_families\", []) || []),\n      ...(pick(otxRelated, \"other.malware_families\", []) || []),\n    ]).slice(0, 25),\n    adversary: uniq([\n      ...(pick(otxRelated, \"alienvault.adversary\", []) || []),\n      ...(pick(otxRelated, \"other.adversary\", []) || []),\n    ]).slice(0, 25),\n    industries: uniq([\n      ...(pick(otxRelated, \"alienvault.industries\", []) || []),\n      ...(pick(otxRelated, \"other.industries\", []) || []),\n    ]).slice(0, 40),\n  },\n  global_references_top: otxReferencesGlobal,\n};\n\n// ---------- Build dense AI brief ----------\nconst enginesLine = vtSummary.engines_flagging_top?.length\n  ? vtSummary.engines_flagging_top.map(e => `${e.engine}(${e.category}:${e.result || \"n/a\"})`).join(\", \")\n  : \"none\";\n\nconst crowdLine = vtSummary.crowdsourced_context_top?.length\n  ? vtSummary.crowdsourced_context_top\n      .map(c => `[${c.severity || \"n/a\"}] ${c.title} (${c.source}) ${c.details}`)\n      .join(\" | \")\n  : \"none\";\n\nconst pulseNames = otxSummary.pulses_top?.length\n  ? otxSummary.pulses_top.map(p => p.name).filter(Boolean).join(\" | \")\n  : \"none\";\n\nconst ai_brief = [\n  `CTI Brief (VirusTotal + AlienVault OTX)`,\n  `Indicator: ${vtSummary.id || otxSummary.indicator || \"N/A\"} | Type: ${vtSummary.type || otxSummary.type || \"unknown\"}`,\n  ``,\n  `--- VirusTotal ---`,\n  `Link: ${vtSummary.link || \"N/A\"}`,\n  `Reputation: ${vtSummary.reputation ?? \"N/A\"} | Votes(H/M): ${vtSummary.votes.harmless}/${vtSummary.votes.malicious}`,\n  `Detections: M=${detections.malicious}, S=${detections.suspicious}, U=${detections.undetected}, H=${detections.harmless}, T=${detections.timeout}`,\n  `Geo/ASN: ${vtSummary.country || \"N/A\"} (${vtSummary.continent || \"N/A\"}) | ASN ${vtSummary.asn || \"N/A\"} ${vtSummary.as_owner ? \"(\" + vtSummary.as_owner + \")\" : \"\"} | Net: ${vtSummary.network || \"N/A\"} | RIR: ${vtSummary.rir || \"N/A\"}`,\n  `Times: first_seen=${vtSummary.first_seen_itw || \"N/A\"} | last_seen=${vtSummary.last_seen_itw || \"N/A\"} | last_analysis=${vtSummary.last_analysis || \"N/A\"} | whois_date=${vtSummary.whois_date || \"N/A\"}`,\n  vtSummary.threat_severity?.level\n    ? `Threat severity: ${vtSummary.threat_severity.level} | bad_collection=${vtSummary.threat_severity.belongs_to_bad_collection ? \"yes\" : \"no\"} | ${safeStr(vtSummary.threat_severity.description, 160)}`\n    : `Threat severity: N/A`,\n  vtSummary.jarm ? `JARM: ${vtSummary.jarm}` : `JARM: N/A`,\n  vtSummary.tags_top?.length ? `Tags(top): ${vtSummary.tags_top.join(\", \")}` : `Tags: none`,\n  `Engines flagging(top): ${enginesLine}`,\n  `Crowdsourced context(top): ${crowdLine}`,\n  ``,\n  `--- AlienVault OTX ---`,\n  `Reputation: ${otxSummary.reputation ?? \"N/A\"} | Pulse count: ${otxSummary.pulse_count ?? 0}`,\n  `Whois: ${otxSummary.whois || \"N/A\"}`,\n  otxSummary.related.malware_families?.length ? `Related malware families: ${otxSummary.related.malware_families.join(\", \")}` : `Related malware families: none`,\n  otxSummary.related.adversary?.length ? `Related adversary: ${otxSummary.related.adversary.join(\", \")}` : `Related adversary: none`,\n  otxSummary.related.industries?.length ? `Related industries: ${otxSummary.related.industries.join(\", \")}` : `Related industries: none`,\n  `Top pulse names: ${pulseNames}`,\n  otxSummary.global_references_top?.length ? `References(top): ${otxSummary.global_references_top.join(\" | \")}` : `References: none`,\n].join(\"\\n\");\n\n// ---------- Output ----------\nreturn [{\n  json: {\n    indicator: vtSummary.id || otxSummary.indicator || null,\n    indicator_type: vtSummary.type || otxSummary.type || \"unknown\",\n    summary: { virustotal: vtSummary, otx: otxSummary },\n    ai_brief,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        144
      ],
      "id": "ad8685eb-7581-4d51-a3d4-db4ce420a26c",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a Threat Intelligence Analyst. You need to redact a report based on the info collected:  {{ $json.ai_brief }}\n",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        1168,
        144
      ],
      "id": "8004bc4d-a022-4ed8-ad53-251e07af9988",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        1104,
        320
      ],
      "id": "94b80c5b-d60c-4423-90c7-854e59038916",
      "name": "OpenAI Chat Model"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        704,
        144
      ],
      "id": "ba24101c-07bd-43fa-a8b7-be24cff5ac8c",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => {\n  const raw = item.json.chatInput;\n\n  const isIPv4 = (s) =>\n    /^(?:(?:25[0-5]|2[0-4]\\d|1?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1?\\d?\\d)$/.test(s);\n\n  const isHash = (s) =>\n    /^[a-fA-F0-9]{32}$/.test(s) ||\n    /^[a-fA-F0-9]{40}$/.test(s) ||\n    /^[a-fA-F0-9]{64}$/.test(s);\n\n  const isUrl = (s) => {\n    try {\n      new URL(s.startsWith(\"http\") ? s : `http://${s}`);\n      return s.includes(\".\") || s.startsWith(\"http\");\n    } catch {\n      return false;\n    }\n  };\n\n  const vtUrlId = (url) => {\n    const fixed = url.startsWith(\"http\") ? url : `http://${url}`;\n    return Buffer.from(fixed)\n      .toString(\"base64\")\n      .replace(/\\+/g, \"-\")\n      .replace(/\\//g, \"_\")\n      .replace(/=+$/g, \"\");\n  };\n\n  let type = \"unknown\";\n  let indicator = raw;\n\n  if (isIPv4(raw)) {\n    type = \"ip\";\n  } else if (isHash(raw)) {\n    type = \"hash\";\n  } else if (isUrl(raw)) {\n    type = \"url\";\n    indicator = raw.startsWith(\"http\") ? raw : `http://${raw}`;\n  }\n\n  let vtPath = \"\";\n  let otxPath = \"\";\n\n  if (type === \"ip\") {\n    vtPath = `/api/v3/ip_addresses/${indicator}`;\n    otxPath = `/api/v1/indicators/IPv4/${indicator}`;\n  } else if (type === \"hash\") {\n    vtPath = `/api/v3/files/${indicator}`;\n    otxPath = `/api/v1/indicators/file/${indicator}`;\n  } else if (type === \"url\") {\n    vtPath = `/api/v3/urls/${vtUrlId(indicator)}`;\n    otxPath = `/api/v1/indicators/url/${encodeURIComponent(indicator)}`;\n  }\n\n  return {\n    json: { input: raw, indicator, type, vtPath, otxPath }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        144
      ],
      "id": "be80a7fe-8367-4e78-9d09-9c0a978dac79",
      "name": "Dynamic Paths"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Preparser_chat\n * - Lee chatInput (puede contener muchos IOCs en varias líneas)\n * - Normaliza saltos, limpia comentarios y ruido\n * - Extrae 1 IOC por línea (o por separadores comunes)\n * - Deduplica manteniendo orden\n * - Devuelve 1 item por IOC como { chatInput: \"<ioc>\" }\n */\n\nconst rawText = ($input.first().json.chatInput || \"\").toString();\n\n// Normaliza saltos\nlet text = rawText.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\").trim();\n\n// Si lo pegaron todo en una sola línea con comas/punto y coma, también lo soporta\nlet parts = text.includes(\"\\n\") ? text.split(\"\\n\") : text.split(/[;,]+/);\n\n// Limpieza\nconst cleaned = parts\n  .map(l => l.trim())\n  .filter(l =>\n    l &&\n    !l.startsWith(\"#\") &&\n    !l.startsWith(\"//\") &&\n    !l.startsWith(\";\") &&\n    !l.startsWith(\"--\")\n  )\n  // quita comillas\n  .map(l => l.replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\"))\n  // primer token (por si hay \"ioc comentario\")\n  .map(l => l.split(/[,\\t; ]+/)[0].trim())\n  .filter(Boolean);\n\n// Dedupe\nconst seen = new Set();\nconst iocs = [];\nfor (const ioc of cleaned) {\n  if (!seen.has(ioc)) {\n    seen.add(ioc);\n    iocs.push(ioc);\n  }\n}\n\n// Salida: 1 item por IOC manteniendo tu contrato\nreturn iocs.map(ioc => ({ json: { chatInput: ioc } }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        144
      ],
      "id": "56c24126-8ce4-4a8b-8cb1-94d8597e46c8",
      "name": "Preparser"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.4,
      "position": [
        -544,
        144
      ],
      "id": "5a9d45e5-7aa0-4ec9-a0ed-ddaea6107d68",
      "name": "When chat message received",
      "webhookId": "12137deb-4409-4b9a-a719-8cc1f793780a"
    }
  ],
  "pinData": {},
  "connections": {
    "VirusTotal HTTP Request": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AlienVault HTTP Request": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Paths": {
      "main": [
        [
          {
            "node": "VirusTotal HTTP Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "AlienVault HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparser": {
      "main": [
        [
          {
            "node": "Dynamic Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "Preparser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "e30ecced-5d0f-4a5c-a72e-e16abebc31b1",
  "meta": {
    "instanceId": "514bd0e6bb04c92acbed75d5bfedbfa635dcb17dfb712421291ed76cc4d79dc3"
  },
  "id": "EsnCxx3HTXhndtBs",
  "tags": []
}
